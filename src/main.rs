// Parse the MIDI file generated by https://ai-midi.com/.
//
// For the Header, only consider `Metrical` timing.
//     The `format` field is ignored.
// For MetaMessages, only consider `Tempo`, `TimeSignature`, and `EndofTrack`.
//     The `TimeSignature` event is ignored.
// For MidiMessages, only consider `NoteOn`, `NoteOff`, and `Controller`.
//     The `vel` field in `NoteOn` and `NoteOff` is ignored.
//     The `Controller` event is ignored.
//
// Assume that only one channel is used.
// Assume that `Tempo` and `TimeSignature` appear before midi events and
// `EndofTrack` appears after them.

use std::{collections::HashMap, fs};

use midly::{
    Header, MetaMessage, MidiMessage, Smf, Timing, TrackEventKind,
    num::{u7, u15, u24},
};

// const MIDI_FILE: &str = "届かない恋.mid";
const MIDI_FILE: &str = "Karma.mid";

struct MetaData {
    tpb: u15,  // Ticks per beat.
    uspb: u24, // Microseconds per beat.
}

impl MetaData {
    fn new(header: &Header) -> Self {
        let tpb = match header.timing {
            Timing::Metrical(ticks) => ticks,
            Timing::Timecode { .. } => todo!(),
        };
        MetaData {
            tpb,
            uspb: u24::from(500_000),
        }
    }
}

fn ticks_to_seconds(ticks: u64, meta_data: &MetaData) -> f64 {
    let mspt = meta_data.uspb.as_int() as f64 / meta_data.tpb.as_int() as f64;
    return ticks as f64 * mspt / 1000000.0;
}

/// This struct will be aligned to the GLSL side.
struct Note {
    begin: f64,
    end: f64,
    note: f64,
}

fn main() {
    let bytes =
        fs::read(format!("../test_assets/{}", MIDI_FILE)).expect("failed to read MIDI file");
    let smf = Smf::parse(&bytes).expect("failed to parse MIDI file");

    // println!("Parsed MIDI file with {} tracks.", smf.tracks.len());

    for track in smf.tracks {
        let mut ticks = 0 as u64;
        let mut meta_data = MetaData::new(&smf.header);
        let mut mapping: HashMap<u7, Note> = HashMap::new();
        let mut notes: Vec<Note> = Vec::new();

        for event in track {
            ticks += event.delta.as_int() as u64;
            match event.kind {
                // MetaMessage.
                TrackEventKind::Meta(MetaMessage::Tempo(mspb)) => meta_data.uspb = mspb,
                TrackEventKind::Meta(MetaMessage::TimeSignature(..)) => {} // Ignored.
                TrackEventKind::Meta(MetaMessage::EndOfTrack) => break,
                // MidiMessage.
                TrackEventKind::Midi {
                    channel: _,
                    message: MidiMessage::NoteOn { key, vel },
                } => update_mapping(
                    key,
                    vel,
                    vel > u7::from(0),
                    ticks_to_seconds(ticks, &meta_data),
                    &mut mapping,
                    &mut notes,
                ),
                TrackEventKind::Midi {
                    channel: _,
                    message: MidiMessage::NoteOff { key, vel },
                } => update_mapping(
                    key,
                    vel,
                    false,
                    ticks_to_seconds(ticks, &meta_data),
                    &mut mapping,
                    &mut notes,
                ),
                TrackEventKind::Midi {
                    channel: _,
                    message: MidiMessage::Controller { .. },
                } => {} // Ignored.
                _ => todo!(),
            }
        }
        assert!(mapping.is_empty());

        println!("struct Note {{");
        println!("    float begin;");
        println!("    float end;");
        println!("    float note;");
        println!("}};");
        println!("#define N {}", notes.len());
        println!("const Note notes[N] = Note[](");
        for (i, note) in notes.iter().enumerate() {
            let comma = if i + 1 < notes.len() { "," } else { "" };
            println!(
                "    Note({:.5}, {:.5}, {:.5}){}",
                note.begin, note.end, note.note, comma
            );
        }
        println!(");")
    }
}

fn update_mapping(
    key: u7,
    _vel: u7,
    is_on: bool,
    seconds: f64,
    mapping: &mut HashMap<u7, Note>,
    notes: &mut Vec<Note>,
) {
    if is_on {
        assert!(!mapping.contains_key(&key));
        mapping.insert(
            key,
            Note {
                begin: seconds,
                end: 0.0, // Will be updated later.
                note: key.as_int() as f64,
            },
        );
    } else {
        assert!(mapping.contains_key(&key));
        let note = mapping.remove(&key).unwrap();
        notes.push(Note {
            begin: note.begin,
            end: seconds,
            note: note.note,
        });
    }
}
