use std::{collections::HashMap, env, fs};

use midly::{
    Header, MetaMessage, MidiMessage, Smf, Timing, TrackEventKind,
    num::{u7, u15, u24},
};

struct MetaData {
    tpb: u15,  // Ticks per beat.
    uspb: u24, // Microseconds per beat.
}

impl MetaData {
    fn new(header: &Header) -> Self {
        let tpb = match header.timing {
            Timing::Metrical(ticks) => ticks,
            Timing::Timecode { .. } => todo!(),
        };
        MetaData {
            tpb,
            uspb: u24::from(500_000),
        }
    }
}

fn ticks_to_seconds(ticks: u64, meta_data: &MetaData) -> f64 {
    let mspt = meta_data.uspb.as_int() as f64 / meta_data.tpb.as_int() as f64;
    return ticks as f64 * mspt / 1000000.0;
}

/// This struct will be aligned to the GLSL side.
struct Note {
    begin: f64,
    end: f64,
    note: f64,
}

fn main() {
    let midi_path = env::args()
        .nth(1)
        .expect("Usage: cargo run --bin parser -- <MIDI_FILE_PATH>.");
    let bytes = fs::read(&midi_path).expect("Failed to read MIDI file.");
    let smf = Smf::parse(&bytes).expect("Failed to parse MIDI file.");

    // println!("Parsed MIDI file with {} tracks.", smf.tracks.len());

    for track in smf.tracks {
        let mut ticks = 0 as u64;
        let mut meta_data = MetaData::new(&smf.header);
        let mut mapping: HashMap<u7, Note> = HashMap::new();
        let mut notes: Vec<Note> = Vec::new();

        for event in track {
            ticks += event.delta.as_int() as u64;
            match event.kind {
                // MetaMessage.
                TrackEventKind::Meta(MetaMessage::Tempo(mspb)) => meta_data.uspb = mspb,
                TrackEventKind::Meta(MetaMessage::TimeSignature(..)) => {} // Ignored.
                TrackEventKind::Meta(MetaMessage::EndOfTrack) => break,
                // MidiMessage.
                TrackEventKind::Midi {
                    channel: _,
                    message: MidiMessage::NoteOn { key, vel },
                } => update_mapping(
                    key,
                    vel,
                    vel > u7::from(0),
                    ticks_to_seconds(ticks, &meta_data),
                    &mut mapping,
                    &mut notes,
                ),
                TrackEventKind::Midi {
                    channel: _,
                    message: MidiMessage::NoteOff { key, vel },
                } => update_mapping(
                    key,
                    vel,
                    false,
                    ticks_to_seconds(ticks, &meta_data),
                    &mut mapping,
                    &mut notes,
                ),
                TrackEventKind::Midi {
                    channel: _,
                    message: MidiMessage::Controller { .. },
                } => {} // Ignored.
                _ => todo!(),
            }
        }
        assert!(mapping.is_empty());

        print_header();
        println!("struct Note {{");
        println!("    float begin;");
        println!("    float end;");
        println!("    float note;");
        println!("}};");
        println!("#define N {}", notes.len());
        println!("const Note notes[N] = Note[](");
        for (i, note) in notes.iter().enumerate() {
            let comma = if i + 1 < notes.len() { "," } else { "" };
            println!(
                "    Note({:.5}, {:.5}, {:.5}){}",
                note.begin, note.end, note.note, comma
            );
        }
        println!(");");
        print_footer();
    }
}

fn update_mapping(
    key: u7,
    _vel: u7,
    is_on: bool,
    seconds: f64,
    mapping: &mut HashMap<u7, Note>,
    notes: &mut Vec<Note>,
) {
    if is_on {
        assert!(!mapping.contains_key(&key));
        mapping.insert(
            key,
            Note {
                begin: seconds,
                end: 0.0, // Will be updated later.
                note: key.as_int() as f64,
            },
        );
    } else {
        assert!(mapping.contains_key(&key));
        let note = mapping.remove(&key).unwrap();
        notes.push(Note {
            begin: note.begin,
            end: seconds,
            note: note.note,
        });
    }
}

fn print_header() {
    let msg = r#"// Generated by https://github.com/o06660o/midi2shadertoy

"#;
    print!("{msg}");
}

fn print_footer() {
    let msg = r#"
// Piano sound from https://www.shadertoy.com/view/XdBSR1.
vec2 pianoSingle(float time, float note) {
    note += 15.;
    if (time < 0.0) return vec2(0.0);

    float sampleX = 0.;

    float mult = pow(2.0, note / 12.0);
    float f = 25. * 55. * mult;
    for (int i = 0; i < 25; i++) {
        sampleX = (sampleX * 1.5 +
                   sin(float(i) * 2. + 6.2831 * f * time) * exp((-1.5 - sqrt(f) / 25.) * time)) /
                  2.5;
        f -= 55. * mult;
    }

    float balanceLeft = 0.75 - note / 12.0;
    float balanceRight = 1.0 - balanceLeft;

    return vec2(sampleX * balanceLeft, sampleX * balanceRight);
}

vec2 mainSound(int samp, float time) {
    vec2 sound = vec2(0.0);
    for (int i = 0; i < N; i++) {
        float bg = notes[i].begin, ed = notes[i].end, note = notes[i].note - 50.0;
        if (time < bg || time > ed) continue;
        sound += pianoSingle(time - bg, note) / 50.0;
    }
    return sound;
}
"#;
    print!("{msg}");
}
